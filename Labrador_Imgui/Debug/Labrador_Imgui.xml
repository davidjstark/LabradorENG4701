<?xml version="1.0"?>
<doc>
    <assembly>
        "Labrador_Imgui"
    </assembly>
    <members>
        <member name="M:PlotControl.controlLab">
            <summary>
Control sampling settings on labrador board
</summary>
        </member>
        <member name="M:PlotControl.renderControl">
            <summary>
Render UI elements for oscilloscope control
</summary>
        </member>
        <member name="T:PlotControl">
            <summary>Oscilloscope Control Widget
</summary>
        </member>
        <member name="M:PlotWidget.Render">
            <summary>
Generic function to render plot widget with correct style
</summary>
        </member>
        <member name="M:PlotWidget.setSize(ImVec2)">
            <summary>
Update size of child window
</summary>
            <param name="new_size">New size</param>
        </member>
        <member name="M:PlotWidget.#ctor(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ImVec2,OSCControl*)">
            <summary>
Constructor
</summary>
            <param name="label">Name of controller</param>
            <param name="size">Child window size</param>
        </member>
        <member name="T:PlotWidget">
            <summary>
Abstract class that draws child that can be populated by a control widget
</summary>
        </member>
        <member name="M:SGControl.controlLab">
            <summary>
Set the Signal Generator on the labrador board.
</summary>
        </member>
        <member name="M:SGControl.renderControl">
            <summary> 
Render UI elements for Signal Generator
</summary>
        </member>
        <member name="T:SGControl">
            <summary>Signal Generator Widget
</summary>
        </member>
        <member name="M:TriangleSignal.controlLab(System.Int32)">
            <summary>
Set the Signal Generator on the labrador board.
</summary>
        </member>
        <member name="T:TriangleSignal">
            <summary>Triangle Signal Generator Widget
</summary>
        </member>
        <member name="M:SawtoothSignal.controlLab(System.Int32)">
            <summary>
Set the Signal Generator on the labrador board.
</summary>
        </member>
        <member name="T:SawtoothSignal">
            <summary>
Sawtooth Signal Generator Widget
</summary>
        </member>
        <member name="M:SquareSignal.controlLab(System.Int32)">
            <summary>
Set the Signal Generator on the labrador board.
</summary>
        </member>
        <member name="T:SquareSignal">
            <summary>
Square Signal Generator Widget
</summary>
        </member>
        <member name="M:SineSignal.controlLab(System.Int32)">
            <summary>
Set the Signal Generator on the labrador board.
</summary>
        </member>
        <member name="M:SineSignal.renderAnnotations">
            <summary>
Render annotations on preview
</summary>
        </member>
        <member name="T:SineSignal">
            <summary>
Sine Signal Generator Widget
</summary>
        </member>
        <member name="M:GenericSignal.turnOff(System.Int32)">
            <summary>
Set signal generator amplitude to zero
</summary>
            <param name="channel" />
        </member>
        <member name="M:GenericSignal.controlLab(System.Int32)">
            <summary>
Set the Signal Generator on the labrador board.
</summary>
        </member>
        <member name="M:GenericSignal.renderPreview">
            <summary>
Render preview of signal
</summary>
        </member>
        <member name="M:GenericSignal.renderControl">
            <summary>
Generic UI elements for Signal Control
</summary>
        </member>
        <member name="T:GenericSignal">
            <summary>
Abstract class representing signal from signal generator
</summary>
        </member>
        <member name="M:OSCControl.controlLab">
            <summary>
Control sampling settings on labrador board
</summary>
        </member>
        <member name="M:OSCControl.renderControl">
            <summary> 
Render UI elements for oscilloscope control
</summary>
        </member>
        <member name="T:OSCControl">
            <summary>Oscilloscope Control Widget
</summary>
        </member>
        <member name="M:SIValue.getMutliplier">
            <summary>
Multiplier to convert prefixed SI unit to standard SI unit, eg mV -&gt; V
</summary>
            <returns />
        </member>
        <member name="M:DropDown(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,std.vector&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,std.allocator&lt;std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;&gt;&gt;,System.Int32*)">
            <summary>
Generic dropdown for list of strings
</summary>
            <param name="id" />
            <param name="options" />
            <param name="active" />
            <param name="size" />
            <returns />
        </member>
        <member name="M:ToggleButton(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,ImVec2,System.Boolean*,System.UInt32,System.UInt32)">
            <summary>
Adapted from https://github.com/ocornut/imgui/issues/1537#issuecomment-355562097
</summary>
            <param name="id" />
            <param name="state" />
            <param name="accentColour" />
        </member>
        <member name="M:ToggleSwitch(System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte!System.Runtime.CompilerServices.IsConst*,System.Boolean*,System.UInt32)">
            <summary>
Adapted from https://github.com/ocornut/imgui/issues/1537#issuecomment-355562097
</summary>
            <param name="id" />
            <param name="state" />
            <param name="accentColour" />
        </member>
        <member name="M:PSUControl.controlLab">
            <summary>
Set the Power Supply Voltage on the labrador board.
</summary>
        </member>
        <member name="M:PSUControl.renderControl">
            <summary> 
Render UI elements for power supply unit
</summary>
        </member>
        <member name="T:PSUControl">
            <summary>Power Suppy Unit Widget
</summary>
        </member>
        <member name="M:ControlWidget.Render">
            <summary>
Generic function to render control widget with correct style
</summary>
        </member>
        <member name="M:ControlWidget.setSize(ImVec2)">
            <summary>
Update size of child window
</summary>
            <param name="new_size">New size</param>
        </member>
        <member name="M:ControlWidget.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;,ImVec2,System.Single!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Constructor
</summary>
            <param name="label">Name of controller</param>
            <param name="size">Child window size</param>
            <param name="borderColor">Accent colour</param>
        </member>
        <member name="T:ControlWidget">
            <summary>
Abstract class that draws control widget such as PSU Control
</summary>
        </member>
        <member name="M:SetControlWidgetStyle(System.Single!System.Runtime.CompilerServices.IsConst*)">
            <summary>
Defines the style of the general control widget
</summary>
            <param name="ac">Accent colour (RGB 0..1) </param>
        </member>
        <member name="M:PreviewStyle">
            <summary>
Defines style for the Signal Generator Preview plot
</summary>
        </member>
        <member name="M:SetGlobalStyle">
            <summary>
Global styles set at the start of the application
</summary>
        </member>
        <member name="M:replace_all(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{Syste">
            <summary>
Replaces all instances of a substring with a provided string
</summary>
            <param name="s" />
            <param name="toReplace" />
            <param name="replaceWith" />
        </member>
        <member name="M:init_constants">
            <summary>
Initialise global preview arrays
</summary>
        </member>
        <member name="T:ImPlot.GetterFuncPtr">
Interprets a user's function pointer as ImPlotPoints
</member>
        <member name="M:libusb_hotplug_get_user_data(libusb_context*,System.Int32)">
\ingroup libusb_hotplug
 * Gets the user_data associated with a hotplug callback.
 *
 * Since version v1.0.24 \ref LIBUSB_API_VERSION &gt;= 0x01000108
 *
 * \param[in] ctx context this callback is registered with
 * \param[in] callback_handle the handle of the callback to get the user_data of

</member>
        <member name="M:libusb_hotplug_deregister_callback(libusb_context*,System.Int32)">
\ingroup libusb_hotplug
 * Deregisters a hotplug callback.
 *
 * Deregister a callback from a libusb_context. This function is safe to call from within
 * a hotplug callback.
 *
 * Since version 1.0.16, \ref LIBUSB_API_VERSION &gt;= 0x01000102
 *
 * \param[in] ctx context this callback is registered with
 * \param[in] callback_handle the handle of the callback to deregister

</member>
        <member name="M:libusb_hotplug_register_callback(libusb_context*,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,=FUNC:System.Int32(libusb_context*,libusb_device*,libusb_hotplug_event,System.Void*),System.Void*,System.Int32*)">
\ingroup libusb_hotplug
 * Register a hotplug callback function
 *
 * Register a callback with the libusb_context. The callback will fire
 * when a matching event occurs on a matching device. The callback is
 * armed until either it is deregistered with libusb_hotplug_deregister_callback()
 * or the supplied callback returns 1 to indicate it is finished processing events.
 *
 * If the \ref LIBUSB_HOTPLUG_ENUMERATE is passed the callback will be
 * called with a \ref LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED for all devices
 * already plugged into the machine. Note that libusb modifies its internal
 * device list from a separate thread, while calling hotplug callbacks from
 * libusb_handle_events(), so it is possible for a device to already be present
 * on, or removed from, its internal device list, while the hotplug callbacks
 * still need to be dispatched. This means that when using \ref
 * LIBUSB_HOTPLUG_ENUMERATE, your callback may be called twice for the arrival
 * of the same device, once from libusb_hotplug_register_callback() and once
 * from libusb_handle_events(); and/or your callback may be called for the
 * removal of a device for which an arrived call was never made.
 *
 * Since version 1.0.16, \ref LIBUSB_API_VERSION &gt;= 0x01000102
 *
 * \param[in] ctx context to register this callback with
 * \param[in] events bitwise or of hotplug events that will trigger this callback.
 *            See \ref libusb_hotplug_event
 * \param[in] flags bitwise or of hotplug flags that affect registration.
 *            See \ref libusb_hotplug_flag
 * \param[in] vendor_id the vendor id to match or \ref LIBUSB_HOTPLUG_MATCH_ANY
 * \param[in] product_id the product id to match or \ref LIBUSB_HOTPLUG_MATCH_ANY
 * \param[in] dev_class the device class to match or \ref LIBUSB_HOTPLUG_MATCH_ANY
 * \param[in] cb_fn the function to be invoked on a matching event/device
 * \param[in] user_data user data to pass to the callback function
 * \param[out] callback_handle pointer to store the handle of the allocated callback (can be NULL)
 * \returns \ref LIBUSB_SUCCESS on success LIBUSB_ERROR code on failure

</member>
        <member name="D:libusb_hotplug_callback_fn">
\ingroup libusb_hotplug
 * Convenience macro when not using any flags 
\ingroup libusb_hotplug
 * Wildcard matching for hotplug events 
\ingroup libusb_hotplug
 * Hotplug callback function type. When requesting hotplug event notifications,
 * you pass a pointer to a callback function of this type.
 *
 * This callback may be called by an internal event thread and as such it is
 * recommended the callback do minimal processing before returning.
 *
 * libusb will call this function later, when a matching event had happened on
 * a matching device. See \ref libusb_hotplug for more information.
 *
 * It is safe to call either libusb_hotplug_register_callback() or
 * libusb_hotplug_deregister_callback() from within a callback function.
 *
 * Since version 1.0.16, \ref LIBUSB_API_VERSION &gt;= 0x01000102
 *
 * \param ctx            context of this notification
 * \param device         libusb_device this event occurred on
 * \param event          event that occurred
 * \param user_data      user data provided when this callback was registered
 * \returns bool whether this callback is finished processing events.
 *                       returning 1 will cause this callback to be deregistered

</member>
        <member name="F:LIBUSB_HOTPLUG_ENUMERATE">
Arm the callback and fire it for all matching currently attached devices. 
</member>
        <member name="F:LIBUSB_HOTPLUG_EVENT_DEVICE_LEFT">
A device has left and is no longer available.
	 * It is the user's responsibility to call libusb_close on any handle associated with a disconnected device.
	 * It is safe to call libusb_get_device_descriptor on a device that has left 
</member>
        <member name="F:LIBUSB_HOTPLUG_EVENT_DEVICE_ARRIVED">
A device has been plugged in and is ready to use 
</member>
        <member name="D:libusb_hotplug_callback_handle">
\ingroup libusb_hotplug
 * Callback handle.
 *
 * Callbacks handles are generated by libusb_hotplug_register_callback()
 * and can be used to deregister callbacks. Callback handles are unique
 * per libusb_context and it is safe to call libusb_hotplug_deregister_callback()
 * on an already deregistered callback.
 *
 * Since version 1.0.16, \ref LIBUSB_API_VERSION &gt;= 0x01000102
 *
 * For more information, see \ref libusb_hotplug.

</member>
        <member name="D:libusb_pollfd_removed_cb">
\ingroup libusb_poll
 * Callback function, invoked when a file descriptor should be removed from
 * the set of file descriptors being monitored for events. After returning
 * from this callback, do not use that file descriptor again.
 * \param fd the file descriptor to stop monitoring
 * \param user_data User data pointer specified in
 * libusb_set_pollfd_notifiers() call
 * \see libusb_set_pollfd_notifiers()

</member>
        <member name="D:libusb_pollfd_added_cb">
\ingroup libusb_poll
 * Callback function, invoked when a new file descriptor should be added
 * to the set of file descriptors monitored for events.
 * \param fd the new file descriptor
 * \param events events to monitor for, see \ref libusb_pollfd for a
 * description
 * \param user_data User data pointer specified in
 * libusb_set_pollfd_notifiers() call
 * \see libusb_set_pollfd_notifiers()

</member>
        <member name="F:libusb_pollfd.fd">
Numeric file descriptor 
</member>
        <member name="T:libusb_pollfd">
\ingroup libusb_poll
 * File descriptor for polling

</member>
        <member name="M:libusb_get_string_descriptor(libusb_device_handle*,System.Byte,System.UInt16,System.Byte*,System.Int32)">
\ingroup libusb_desc
 * Retrieve a descriptor from a device.
 * This is a convenience function which formulates the appropriate control
 * message to retrieve the descriptor. The string returned is Unicode, as
 * detailed in the USB specifications.
 *
 * \param dev_handle a device handle
 * \param desc_index the index of the descriptor to retrieve
 * \param langid the language ID for the string descriptor
 * \param data output buffer for descriptor
 * \param length size of data buffer
 * \returns number of bytes returned in data, or LIBUSB_ERROR code on failure
 * \see libusb_get_string_descriptor_ascii()

</member>
        <member name="M:libusb_get_descriptor(libusb_device_handle*,System.Byte,System.Byte,System.Byte*,System.Int32)">
\ingroup libusb_desc
 * Retrieve a descriptor from the default control pipe.
 * This is a convenience function which formulates the appropriate control
 * message to retrieve the descriptor.
 *
 * \param dev_handle a device handle
 * \param desc_type the descriptor type, see \ref libusb_descriptor_type
 * \param desc_index the index of the descriptor to retrieve
 * \param data output buffer for descriptor
 * \param length size of data buffer
 * \returns number of bytes returned in data, or LIBUSB_ERROR code on failure

</member>
        <member name="M:libusb_fill_control_setup(System.Byte*,System.Byte,System.Byte,System.UInt16,System.UInt16,System.UInt16)">
\ingroup libusb_asyncio
 * Helper function to populate the setup packet (first 8 bytes of the data
 * buffer) for a control transfer. The wIndex, wValue and wLength values should
 * be given in host-endian byte order.
 *
 * \param buffer buffer to output the setup packet into
 * This pointer must be aligned to at least 2 bytes boundary.
 * \param bmRequestType see the
 * \ref libusb_control_setup::bmRequestType "bmRequestType" field of
 * \ref libusb_control_setup
 * \param bRequest see the
 * \ref libusb_control_setup::bRequest "bRequest" field of
 * \ref libusb_control_setup
 * \param wValue see the
 * \ref libusb_control_setup::wValue "wValue" field of
 * \ref libusb_control_setup
 * \param wIndex see the
 * \ref libusb_control_setup::wIndex "wIndex" field of
 * \ref libusb_control_setup
 * \param wLength see the
 * \ref libusb_control_setup::wLength "wLength" field of
 * \ref libusb_control_setup

</member>
        <member name="T:libusb_init_option">
\ingroup libusb_lib
 * Structure used for setting options through \ref libusb_init_context.
 *

</member>
        <member name="T:libusb_option">
\ingroup libusb_lib
 * Available option values for libusb_set_option() and libusb_init_context().


Which option to set 
</member>
        <member name="F:LIBUSB_OPTION_LOG_CB">
Set the context log callback function.
	 *
	 * Set the log callback function either on a context or globally. This
	 * option must be provided an argument of type \ref libusb_log_cb.
	 * Using this option with a NULL context is equivalent to calling
	 * libusb_set_log_cb() with mode \ref LIBUSB_LOG_CB_GLOBAL.
	 * Using it with a non-NULL context is equivalent to calling
	 * libusb_set_log_cb() with mode \ref LIBUSB_LOG_CB_CONTEXT.

</member>
        <member name="F:LIBUSB_OPTION_NO_DEVICE_DISCOVERY">
Do not scan for devices
	 *
	 * With this option set, libusb will skip scanning devices in
	 * libusb_init_context().
	 *
	 * Hotplug functionality will also be deactivated.
	 *
	 * The option is useful in combination with libusb_wrap_sys_device(),
	 * which can access a device directly without prior device scanning.
	 *
	 * This is typically needed on Android, where access to USB devices
	 * is limited.
	 *
	 * This option should only be used with libusb_init_context()
	 * otherwise unspecified behavior may occur.
	 *
	 * Only valid on Linux. Ignored on all other platforms.

</member>
        <member name="F:LIBUSB_OPTION_USE_USBDK">
Use the UsbDk backend for a specific context, if available.
	 *
	 * This option should be set at initialization with libusb_init_context()
	 * otherwise unspecified behavior may occur.
	 *
	 * Only valid on Windows. Ignored on all other platforms.

</member>
        <member name="F:LIBUSB_OPTION_LOG_LEVEL">
Set the log message verbosity.
	 *
	 * This option must be provided an argument of type \ref libusb_log_level.
	 * The default level is LIBUSB_LOG_LEVEL_NONE, which means no messages are ever
	 * printed. If you choose to increase the message verbosity level, ensure
	 * that your application does not close the stderr file descriptor.
	 *
	 * You are advised to use level LIBUSB_LOG_LEVEL_WARNING. libusb is conservative
	 * with its message logging and most of the time, will only log messages that
	 * explain error conditions and other oddities. This will help you debug
	 * your software.
	 *
	 * If the LIBUSB_DEBUG environment variable was set when libusb was
	 * initialized, this option does nothing: the message verbosity is fixed
	 * to the value in the environment variable.
	 *
	 * If libusb was compiled without any message logging, this option does
	 * nothing: you'll never get any messages.
	 *
	 * If libusb was compiled with verbose debug message logging, this option
	 * does nothing: you'll always get messages from all levels.

</member>
        <member name="T:libusb_log_cb_mode">
\ingroup libusb_lib
 *  Log callback mode.
 *
 *  Since version 1.0.23, \ref LIBUSB_API_VERSION &gt;= 0x01000107
 *
 * \see libusb_set_log_cb()

</member>
        <member name="F:LIBUSB_LOG_CB_CONTEXT">
Callback function handling context related log messages. 
</member>
        <member name="F:LIBUSB_LOG_CB_GLOBAL">
Callback function handling all log messages. 
</member>
        <member name="T:libusb_log_level">
\ingroup libusb_lib
 *  Log message levels.


\ingroup libusb_lib
 * Callback function for handling log messages.
 * \param ctx the context which is related to the log message, or NULL if it
 * is a global log message
 * \param level the log level, see \ref libusb_log_level for a description
 * \param str the log message
 *
 * Since version 1.0.23, \ref LIBUSB_API_VERSION &gt;= 0x01000107
 *
 * \see libusb_set_log_cb()

</member>
        <member name="F:LIBUSB_LOG_LEVEL_DEBUG">
(4) : All messages are emitted 
</member>
        <member name="F:LIBUSB_LOG_LEVEL_INFO">
(3) : Informational, warning and error messages are emitted 
</member>
        <member name="F:LIBUSB_LOG_LEVEL_WARNING">
(2) : Warning and error messages are emitted 
</member>
        <member name="F:LIBUSB_LOG_LEVEL_ERROR">
(1) : Error messages are emitted 
</member>
        <member name="F:LIBUSB_LOG_LEVEL_NONE">
(0) : No messages ever emitted by the library (default) 
</member>
        <member name="T:libusb_capability">
\ingroup libusb_misc
 * Capabilities supported by an instance of libusb on the current running
 * platform. Test if the loaded library supports a given capability by calling
 * \ref libusb_has_capability().

</member>
        <member name="F:LIBUSB_CAP_SUPPORTS_DETACH_KERNEL_DRIVER">
The library supports detaching of the default USB driver, using
	 * \ref libusb_detach_kernel_driver(), if one is set by the OS kernel 
</member>
        <member name="F:LIBUSB_CAP_HAS_HID_ACCESS">
The library can access HID devices without requiring user intervention.
	 * Note that before being able to actually access an HID device, you may
	 * still have to call additional libusb functions such as
	 * \ref libusb_detach_kernel_driver(). 
</member>
        <member name="F:LIBUSB_CAP_HAS_HOTPLUG">
Hotplug support is available on this platform. 
</member>
        <member name="F:LIBUSB_CAP_HAS_CAPABILITY">
The libusb_has_capability() API is available. 
</member>
        <member name="F:libusb_transfer.num_iso_packets">
Number of isochronous packets. Only used for I/O with isochronous
	 * endpoints. Must be non-negative. 
</member>
        <member name="F:libusb_transfer.buffer">
Data buffer 
</member>
        <member name="F:libusb_transfer.user_data">
User context data. Useful for associating specific data to a transfer
	 * that can be accessed from within the callback function.
	 *
	 * This field may be set manually or is taken as the `user_data` parameter
	 * of the following functions:
	 * - libusb_fill_bulk_transfer()
	 * - libusb_fill_bulk_stream_transfer()
	 * - libusb_fill_control_transfer()
	 * - libusb_fill_interrupt_transfer()
	 * - libusb_fill_iso_transfer() 
</member>
        <member name="F:libusb_transfer.callback">
Callback function. This will be invoked when the transfer completes,
	 * fails, or is cancelled. 
</member>
        <member name="F:libusb_transfer.actual_length">
Actual length of data that was transferred. Read-only, and only for
	 * use within transfer callback function. Not valid for isochronous
	 * endpoint transfers. 
</member>
        <member name="F:libusb_transfer.length">
Length of the data buffer. Must be non-negative. 
</member>
        <member name="F:libusb_transfer.timeout">
Timeout for this transfer in milliseconds. A value of 0 indicates no
	 * timeout. 
</member>
        <member name="F:libusb_transfer.type">
Type of the transfer from \ref libusb_transfer_type 
</member>
        <member name="F:libusb_transfer.endpoint">
Address of the endpoint where this transfer will be sent. 
</member>
        <member name="F:libusb_transfer.flags">
A bitwise OR combination of \ref libusb_transfer_flags. 
</member>
        <member name="F:libusb_transfer.dev_handle">
Handle of the device that this transfer will be submitted to 
</member>
        <member name="T:libusb_transfer">
\ingroup libusb_asyncio
 * Asynchronous transfer callback function type. When submitting asynchronous
 * transfers, you pass a pointer to a callback function of this type via the
 * \ref libusb_transfer::callback "callback" member of the libusb_transfer
 * structure. libusb will call this function later, when the transfer has
 * completed or failed. See \ref libusb_asyncio for more information.
 * \param transfer The libusb_transfer struct the callback function is being
 * notified about.


\ingroup libusb_asyncio
 * The generic USB transfer structure. The user populates this structure and
 * then submits it in order to request a transfer. After the transfer has
 * completed, the library populates the transfer with the results and passes
 * it back to the user.


\ingroup libusb_asyncio
 * Get the data section of a control transfer. This convenience function is here
 * to remind you that the data does not start until 8 bytes into the actual
 * buffer, as the setup packet comes first.
 *
 * Calling this function only makes sense from a transfer callback function,
 * or situations where you have already allocated a suitably sized buffer at
 * transfer-&gt;buffer.
 *
 * \param transfer a transfer
 * \returns pointer to the first byte of the data section


\ingroup libusb_asyncio
 * Helper function to populate the required \ref libusb_transfer fields
 * for a control transfer.
 *
 * If you pass a transfer buffer to this function, the first 8 bytes will
 * be interpreted as a control setup packet, and the wLength field will be
 * used to automatically populate the \ref libusb_transfer::length "length"
 * field of the transfer. Therefore the recommended approach is:
 * -# Allocate a suitably sized data buffer (including space for control setup)
 * -# Call libusb_fill_control_setup()
 * -# If this is a host-to-device transfer with a data stage, put the data
 *    in place after the setup packet
 * -# Call this function
 * -# Call libusb_submit_transfer()
 *
 * It is also legal to pass a NULL buffer to this function, in which case this
 * function will not attempt to populate the length field. Remember that you
 * must then populate the buffer and length fields later.
 *
 * \param transfer the transfer to populate
 * \param dev_handle handle of the device that will handle the transfer
 * \param buffer data buffer. If provided, this function will interpret the
 * first 8 bytes as a setup packet and infer the transfer length from that.
 * This pointer must be aligned to at least 2 bytes boundary.
 * \param callback callback function to be invoked on transfer completion
 * \param user_data user data to pass to callback function
 * \param timeout timeout for the transfer in milliseconds


\ingroup libusb_asyncio
 * Helper function to populate the required \ref libusb_transfer fields
 * for a bulk transfer.
 *
 * \param transfer the transfer to populate
 * \param dev_handle handle of the device that will handle the transfer
 * \param endpoint address of the endpoint where this transfer will be sent
 * \param buffer data buffer
 * \param length length of data buffer
 * \param callback callback function to be invoked on transfer completion
 * \param user_data user data to pass to callback function
 * \param timeout timeout for the transfer in milliseconds


\ingroup libusb_asyncio
 * Helper function to populate the required \ref libusb_transfer fields
 * for a bulk transfer using bulk streams.
 *
 * Since version 1.0.19, \ref LIBUSB_API_VERSION &gt;= 0x01000103
 *
 * \param transfer the transfer to populate
 * \param dev_handle handle of the device that will handle the transfer
 * \param endpoint address of the endpoint where this transfer will be sent
 * \param stream_id bulk stream id for this transfer
 * \param buffer data buffer
 * \param length length of data buffer
 * \param callback callback function to be invoked on transfer completion
 * \param user_data user data to pass to callback function
 * \param timeout timeout for the transfer in milliseconds


\ingroup libusb_asyncio
 * Helper function to populate the required \ref libusb_transfer fields
 * for an interrupt transfer.
 *
 * \param transfer the transfer to populate
 * \param dev_handle handle of the device that will handle the transfer
 * \param endpoint address of the endpoint where this transfer will be sent
 * \param buffer data buffer
 * \param length length of data buffer
 * \param callback callback function to be invoked on transfer completion
 * \param user_data user data to pass to callback function
 * \param timeout timeout for the transfer in milliseconds


\ingroup libusb_asyncio
 * Helper function to populate the required \ref libusb_transfer fields
 * for an isochronous transfer.
 *
 * \param transfer the transfer to populate
 * \param dev_handle handle of the device that will handle the transfer
 * \param endpoint address of the endpoint where this transfer will be sent
 * \param buffer data buffer
 * \param length length of data buffer
 * \param num_iso_packets the number of isochronous packets
 * \param callback callback function to be invoked on transfer completion
 * \param user_data user data to pass to callback function
 * \param timeout timeout for the transfer in milliseconds


\ingroup libusb_asyncio
 * Convenience function to set the length of all packets in an isochronous
 * transfer, based on the num_iso_packets field in the transfer structure.
 *
 * \param transfer a transfer
 * \param length the length to set in each isochronous packet descriptor
 * \see libusb_get_max_packet_size()


\ingroup libusb_asyncio
 * Convenience function to locate the position of an isochronous packet
 * within the buffer of an isochronous transfer.
 *
 * This is a thorough function which loops through all preceding packets,
 * accumulating their lengths to find the position of the specified packet.
 * Typically you will assign equal lengths to each packet in the transfer,
 * and hence the above method is sub-optimal. You may wish to use
 * libusb_get_iso_packet_buffer_simple() instead.
 *
 * \param transfer a transfer
 * \param packet the packet to return the address of
 * \returns the base address of the packet buffer inside the transfer buffer,
 * or NULL if the packet does not exist.
 * \see libusb_get_iso_packet_buffer_simple()


\ingroup libusb_asyncio
 * Convenience function to locate the position of an isochronous packet
 * within the buffer of an isochronous transfer, for transfers where each
 * packet is of identical size.
 *
 * This function relies on the assumption that every packet within the transfer
 * is of identical size to the first packet. Calculating the location of
 * the packet buffer is then just a simple calculation:
 * <tt>buffer + (packet_size * packet)</tt>
 *
 * Do not use this function on transfers other than those that have identical
 * packet lengths for each packet.
 *
 * \param transfer a transfer
 * \param packet the packet to return the address of
 * \returns the base address of the packet buffer inside the transfer buffer,
 * or NULL if the packet does not exist.
 * \see libusb_get_iso_packet_buffer()

</member>
        <member name="F:libusb_iso_packet_descriptor.actual_length">
Amount of data that was actually transferred 
</member>
        <member name="F:libusb_iso_packet_descriptor.length">
Length of data to request in this packet 
</member>
        <member name="T:libusb_iso_packet_descriptor">
\ingroup libusb_asyncio
 * Isochronous packet descriptor. 

Isochronous packet descriptors, for isochronous transfers only. 
</member>
        <member name="T:libusb_transfer_flags">
\ingroup libusb_asyncio
 * libusb_transfer.flags values 
</member>
        <member name="F:LIBUSB_TRANSFER_ADD_ZERO_PACKET">
Terminate transfers that are a multiple of the endpoint's
	 * wMaxPacketSize with an extra zero length packet. This is useful
	 * when a device protocol mandates that each logical request is
	 * terminated by an incomplete packet (i.e. the logical requests are
	 * not separated by other means).
	 *
	 * This flag only affects host-to-device transfers to bulk and interrupt
	 * endpoints. In other situations, it is ignored.
	 *
	 * This flag only affects transfers with a length that is a multiple of
	 * the endpoint's wMaxPacketSize. On transfers of other lengths, this
	 * flag has no effect. Therefore, if you are working with a device that
	 * needs a ZLP whenever the end of the logical request falls on a packet
	 * boundary, then it is sensible to set this flag on <em>every</em>
	 * transfer (you do not have to worry about only setting it on transfers
	 * that end on the boundary).
	 *
	 * This flag is currently only supported on Linux.
	 * On other systems, libusb_submit_transfer() will return
	 * \ref LIBUSB_ERROR_NOT_SUPPORTED for every transfer where this
	 * flag is set.
	 *
	 * Available since libusb-1.0.9.

</member>
        <member name="F:LIBUSB_TRANSFER_FREE_TRANSFER">
Automatically call libusb_free_transfer() after callback returns.
	 * If this flag is set, it is illegal to call libusb_free_transfer()
	 * from your transfer callback, as this will result in a double-free
	 * when this flag is acted upon. 
</member>
        <member name="F:LIBUSB_TRANSFER_FREE_BUFFER">
Automatically free() transfer buffer during libusb_free_transfer().
	 * Note that buffers allocated with libusb_dev_mem_alloc() should not
	 * be attempted freed in this way, since free() is not an appropriate
	 * way to release such memory. 
</member>
        <member name="F:LIBUSB_TRANSFER_SHORT_NOT_OK">
Report short frames as errors 
</member>
        <member name="T:libusb_transfer_status">
\ingroup libusb_asyncio
 * Transfer status codes 

Status code for this packet 

The status of the transfer. Read-only, and only for use within
	 * transfer callback function.
	 *
	 * If this is an isochronous transfer, this field may read COMPLETED even
	 * if there were errors in the frames. Use the
	 * \ref libusb_iso_packet_descriptor::status "status" field in each packet
	 * to determine if errors occurred. 
</member>
        <member name="F:LIBUSB_TRANSFER_OVERFLOW">
Device sent more data than requested 
</member>
        <member name="F:LIBUSB_TRANSFER_NO_DEVICE">
Device was disconnected 
</member>
        <member name="F:LIBUSB_TRANSFER_STALL">
For bulk/interrupt endpoints: halt condition detected (endpoint
	 * stalled). For control endpoints: control request not supported. 
</member>
        <member name="F:LIBUSB_TRANSFER_CANCELLED">
Transfer was cancelled 
</member>
        <member name="F:LIBUSB_TRANSFER_TIMED_OUT">
Transfer timed out 
</member>
        <member name="F:LIBUSB_TRANSFER_ERROR">
Transfer failed 
</member>
        <member name="F:LIBUSB_TRANSFER_COMPLETED">
Transfer completed without error. Note that this does not indicate
	 * that the entire amount of requested data was transferred. 
</member>
        <member name="T:libusb_transfer_type">
\ingroup libusb_asyncio
 * Transfer type 
</member>
        <member name="F:LIBUSB_TRANSFER_TYPE_BULK_STREAM">
Bulk stream transfer 
</member>
        <member name="F:LIBUSB_TRANSFER_TYPE_INTERRUPT">
Interrupt transfer 
</member>
        <member name="F:LIBUSB_TRANSFER_TYPE_BULK">
Bulk transfer 
</member>
        <member name="F:LIBUSB_TRANSFER_TYPE_ISOCHRONOUS">
Isochronous transfer 
</member>
        <member name="F:LIBUSB_TRANSFER_TYPE_CONTROL">
Control transfer 
</member>
        <member name="T:libusb_error">
\ingroup libusb_misc
 * Error codes. Most libusb functions return 0 on success or one of these
 * codes on failure.
 * You can call libusb_error_name() to retrieve a string representation of an
 * error code or libusb_strerror() to get an end-user suitable description of
 * an error code.

</member>
        <member name="F:LIBUSB_ERROR_OTHER">
Other error 
</member>
        <member name="F:LIBUSB_ERROR_NOT_SUPPORTED">
Operation not supported or unimplemented on this platform 
</member>
        <member name="F:LIBUSB_ERROR_NO_MEM">
Insufficient memory 
</member>
        <member name="F:LIBUSB_ERROR_INTERRUPTED">
System call interrupted (perhaps due to signal) 
</member>
        <member name="F:LIBUSB_ERROR_PIPE">
Pipe error 
</member>
        <member name="F:LIBUSB_ERROR_OVERFLOW">
Overflow 
</member>
        <member name="F:LIBUSB_ERROR_TIMEOUT">
Operation timed out 
</member>
        <member name="F:LIBUSB_ERROR_BUSY">
Resource busy 
</member>
        <member name="F:LIBUSB_ERROR_NOT_FOUND">
Entity not found 
</member>
        <member name="F:LIBUSB_ERROR_NO_DEVICE">
No such device (it may have been disconnected) 
</member>
        <member name="F:LIBUSB_ERROR_ACCESS">
Access denied (insufficient permissions) 
</member>
        <member name="F:LIBUSB_ERROR_INVALID_PARAM">
Invalid parameter 
</member>
        <member name="F:LIBUSB_ERROR_IO">
Input/output error 
</member>
        <member name="F:LIBUSB_SUCCESS">
Success (no error) 
</member>
        <member name="T:libusb_speed">
\ingroup libusb_dev
 * Speed codes. Indicates the speed at which the device is operating.

</member>
        <member name="F:LIBUSB_SPEED_SUPER_PLUS">
The device is operating at super speed plus (10000MBit/s). 
</member>
        <member name="F:LIBUSB_SPEED_SUPER">
The device is operating at super speed (5000MBit/s). 
</member>
        <member name="F:LIBUSB_SPEED_HIGH">
The device is operating at high speed (480MBit/s). 
</member>
        <member name="F:LIBUSB_SPEED_FULL">
The device is operating at full speed (12MBit/s). 
</member>
        <member name="F:LIBUSB_SPEED_LOW">
The device is operating at low speed (1.5MBit/s). 
</member>
        <member name="F:LIBUSB_SPEED_UNKNOWN">
The OS doesn't report or know the device speed. 
</member>
        <member name="T:libusb_device_handle">
\ingroup libusb_dev
 * Structure representing a handle on a USB device. This is an opaque type for
 * which you are only ever provided with a pointer, usually originating from
 * libusb_open().
 *
 * A device handle is used to perform I/O and other operations. When finished
 * with a device handle, you should call libusb_close().

</member>
        <member name="T:libusb_device">
\ingroup libusb_dev
 * Structure representing a USB device detected on the system. This is an
 * opaque type for which you are only ever provided with a pointer, usually
 * originating from libusb_get_device_list() or libusb_hotplug_register_callback().
 *
 * Certain operations can be performed on a device, but in order to do any
 * I/O you will have to first obtain a device handle using libusb_open().
 *
 * Devices are reference counted with libusb_ref_device() and
 * libusb_unref_device(), and are freed when the reference count reaches 0.
 * New devices presented by libusb_get_device_list() have a reference count of
 * 1, and libusb_free_device_list() can optionally decrease the reference count
 * on all devices in the list. libusb_open() adds another reference which is
 * later destroyed by libusb_close().

</member>
        <member name="T:libusb_context">
\ingroup libusb_lib
 * Structure representing a libusb session. The concept of individual libusb
 * sessions allows for your program to use two libraries (or dynamically
 * load two modules) which both independently use libusb. This will prevent
 * interference between the individual libusb users - for example
 * libusb_set_option() will not affect the other user of the library, and
 * libusb_exit() will not destroy resources that the other user is still
 * using.
 *
 * Sessions are created by libusb_init_context() and destroyed through libusb_exit().
 * If your application is guaranteed to only ever include a single libusb
 * user (i.e. you), you do not have to worry about contexts: pass NULL in
 * every function call where a context is required, and the default context
 * will be used. Note that libusb_set_option(NULL, ...) is special, and adds
 * an option to a list of default options for new contexts.
 *
 * For more information, see \ref libusb_contexts.

</member>
        <member name="F:libusb_version.describe">
For ABI compatibility only. 
</member>
        <member name="F:libusb_version.rc">
Library release candidate suffix string, e.g. "-rc4". 
</member>
        <member name="F:libusb_version.nano">
Library nano version. 
</member>
        <member name="F:libusb_version.micro">
Library micro version. 
</member>
        <member name="F:libusb_version.minor">
Library minor version. 
</member>
        <member name="F:libusb_version.major">
Library major version. 
</member>
        <member name="T:libusb_version">
\ingroup libusb_lib
 * Structure providing the version of the libusb runtime

</member>
        <member name="F:libusb_control_setup.wLength">
Number of bytes to transfer 
</member>
        <member name="F:libusb_control_setup.wIndex">
Index. Varies according to request, typically used to pass an index
	 * or offset 
</member>
        <member name="F:libusb_control_setup.wValue">
Value. Varies according to request 
</member>
        <member name="F:libusb_control_setup.bRequest">
Request. If the type bits of bmRequestType are equal to
	 * \ref libusb_request_type::LIBUSB_REQUEST_TYPE_STANDARD
	 * "LIBUSB_REQUEST_TYPE_STANDARD" then this field refers to
	 * \ref libusb_standard_request. For other cases, use of this field is
	 * application-specific. 
</member>
        <member name="F:libusb_control_setup.bmRequestType">
Request type. Bits 0:4 determine recipient, see
	 * \ref libusb_request_recipient. Bits 5:6 determine type, see
	 * \ref libusb_request_type. Bit 7 determines data transfer direction, see
	 * \ref libusb_endpoint_direction.

</member>
        <member name="T:libusb_control_setup">
\ingroup libusb_asyncio
 * Setup packet for control transfers. 

\ingroup libusb_asyncio
 * Get the control setup packet of a control transfer. This convenience
 * function is here to remind you that the control setup occupies the first
 * 8 bytes of the transfer data buffer.
 *
 * Calling this function only makes sense from a transfer callback function,
 * or situations where you have already allocated a suitably sized buffer at
 * transfer-&gt;buffer.
 *
 * \param transfer a transfer
 * \returns a casted pointer to the start of the transfer data buffer

</member>
        <member name="F:libusb_platform_descriptor.CapabilityData">
Capability data (bLength - 20) 
</member>
        <member name="F:libusb_platform_descriptor.PlatformCapabilityUUID">
128 bit UUID 
</member>
        <member name="F:libusb_platform_descriptor.bReserved">
Reserved field 
</member>
        <member name="F:libusb_platform_descriptor.bDevCapabilityType">
Capability type. Will have value
	 * \ref libusb_capability_type::LIBUSB_BT_PLATFORM_DESCRIPTOR
	 * LIBUSB_BT_CONTAINER_ID in this context. 
</member>
        <member name="F:libusb_platform_descriptor.bDescriptorType">
Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. 
</member>
        <member name="F:libusb_platform_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_platform_descriptor">
\ingroup libusb_desc
 * A structure representing a Platform descriptor.
 * This descriptor is documented in section 9.6.2.4 of the USB 3.2 specification.

</member>
        <member name="F:libusb_container_id_descriptor.ContainerID">
128 bit UUID 
</member>
        <member name="F:libusb_container_id_descriptor.bReserved">
Reserved field 
</member>
        <member name="F:libusb_container_id_descriptor.bDevCapabilityType">
Capability type. Will have value
	 * \ref libusb_capability_type::LIBUSB_BT_CONTAINER_ID
	 * LIBUSB_BT_CONTAINER_ID in this context. 
</member>
        <member name="F:libusb_container_id_descriptor.bDescriptorType">
Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. 
</member>
        <member name="F:libusb_container_id_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_container_id_descriptor">
\ingroup libusb_desc
 * A structure representing the Container ID descriptor.
 * This descriptor is documented in section 9.6.2.3 of the USB 3.0 specification.
 * All multiple-byte fields, except UUIDs, are represented in host-endian format.

</member>
        <member name="F:libusb_ss_usb_device_capability_descriptor.bU2DevExitLat">
U2 Device Exit Latency. 
</member>
        <member name="F:libusb_ss_usb_device_capability_descriptor.bU1DevExitLat">
U1 Device Exit Latency. 
</member>
        <member name="F:libusb_ss_usb_device_capability_descriptor.bFunctionalitySupport">
The lowest speed at which all the functionality supported
	 * by the device is available to the user. For example if the
	 * device supports all its functionality when connected at
	 * full speed and above then it sets this value to 1. 
</member>
        <member name="F:libusb_ss_usb_device_capability_descriptor.wSpeedSupported">
Bitmap encoding of the speed supported by this device when
	 * operating in SuperSpeed mode. See \ref libusb_supported_speed. 
</member>
        <member name="F:libusb_ss_usb_device_capability_descriptor.bmAttributes">
Bitmap encoding of supported device level features.
	 * A value of one in a bit location indicates a feature is
	 * supported; a value of zero indicates it is not supported.
	 * See \ref libusb_ss_usb_device_capability_attributes. 
</member>
        <member name="F:libusb_ss_usb_device_capability_descriptor.bDevCapabilityType">
Capability type. Will have value
	 * \ref libusb_capability_type::LIBUSB_BT_SS_USB_DEVICE_CAPABILITY
	 * LIBUSB_BT_SS_USB_DEVICE_CAPABILITY in this context. 
</member>
        <member name="F:libusb_ss_usb_device_capability_descriptor.bDescriptorType">
Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. 
</member>
        <member name="F:libusb_ss_usb_device_capability_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_ss_usb_device_capability_descriptor">
\ingroup libusb_desc
 * A structure representing the SuperSpeed USB Device Capability descriptor
 * This descriptor is documented in section 9.6.2.2 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.

</member>
        <member name="F:libusb_usb_2_0_extension_descriptor.bmAttributes">
Bitmap encoding of supported device level features.
	 * A value of one in a bit location indicates a feature is
	 * supported; a value of zero indicates it is not supported.
	 * See \ref libusb_usb_2_0_extension_attributes. 
</member>
        <member name="F:libusb_usb_2_0_extension_descriptor.bDevCapabilityType">
Capability type. Will have value
	 * \ref libusb_capability_type::LIBUSB_BT_USB_2_0_EXTENSION
	 * LIBUSB_BT_USB_2_0_EXTENSION in this context. 
</member>
        <member name="F:libusb_usb_2_0_extension_descriptor.bDescriptorType">
Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. 
</member>
        <member name="F:libusb_usb_2_0_extension_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_usb_2_0_extension_descriptor">
\ingroup libusb_desc
 * A structure representing the USB 2.0 Extension descriptor
 * This descriptor is documented in section 9.6.2.1 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.

</member>
        <member name="F:libusb_bos_descriptor.bNumDeviceCaps">
The number of separate device capability descriptors in
	 * the BOS 
</member>
        <member name="F:libusb_bos_descriptor.wTotalLength">
Length of this descriptor and all of its sub descriptors 
</member>
        <member name="F:libusb_bos_descriptor.bDescriptorType">
Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_BOS LIBUSB_DT_BOS
	 * in this context. 
</member>
        <member name="F:libusb_bos_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_bos_descriptor">
\ingroup libusb_desc
 * A structure representing the Binary Device Object Store (BOS) descriptor.
 * This descriptor is documented in section 9.6.2 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.

</member>
        <member name="F:libusb_bos_dev_capability_descriptor.dev_capability_data">
Device Capability data (bLength - 3 bytes) 
</member>
        <member name="F:libusb_bos_dev_capability_descriptor.bDevCapabilityType">
Device Capability type 
</member>
        <member name="F:libusb_bos_dev_capability_descriptor.bDescriptorType">
Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE_CAPABILITY
	 * LIBUSB_DT_DEVICE_CAPABILITY in this context. 
</member>
        <member name="F:libusb_bos_dev_capability_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_bos_dev_capability_descriptor">
\ingroup libusb_desc
 * A generic representation of a BOS Device Capability descriptor. It is
 * advised to check bDevCapabilityType and call the matching
 * libusb_get_*_descriptor function to get a structure fully matching the type.


bNumDeviceCap Device Capability Descriptors 
</member>
        <member name="F:libusb_ss_endpoint_companion_descriptor.wBytesPerInterval">
The total number of bytes this EP will transfer every
	 *  service interval. Valid only for periodic EPs. 
</member>
        <member name="F:libusb_ss_endpoint_companion_descriptor.bmAttributes">
In bulk EP: bits 4:0 represents the maximum number of
	 *  streams the EP supports. In isochronous EP: bits 1:0
	 *  represents the Mult - a zero based value that determines
	 *  the maximum number of packets within a service interval  
</member>
        <member name="F:libusb_ss_endpoint_companion_descriptor.bMaxBurst">
The maximum number of packets the endpoint can send or
	 *  receive as part of a burst. 
</member>
        <member name="F:libusb_ss_endpoint_companion_descriptor.bDescriptorType">
Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_SS_ENDPOINT_COMPANION in
	 * this context. 
</member>
        <member name="F:libusb_ss_endpoint_companion_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_ss_endpoint_companion_descriptor">
\ingroup libusb_desc
 * A structure representing the superspeed endpoint companion
 * descriptor. This descriptor is documented in section 9.6.7 of
 * the USB 3.0 specification. All multiple-byte fields are represented in
 * host-endian format.

</member>
        <member name="F:libusb_config_descriptor.extra_length">
Length of the extra descriptors, in bytes. Must be non-negative. 
</member>
        <member name="F:libusb_config_descriptor.extra">
Extra descriptors. If libusb encounters unknown configuration
	 * descriptors, it will store them here, should you wish to parse them. 
</member>
        <member name="F:libusb_config_descriptor.MaxPower">
Maximum power consumption of the USB device from this bus in this
	 * configuration when the device is fully operation. Expressed in units
	 * of 2 mA when the device is operating in high-speed mode and in units
	 * of 8 mA when the device is operating in super-speed mode. 
</member>
        <member name="F:libusb_config_descriptor.bmAttributes">
Configuration characteristics 
</member>
        <member name="F:libusb_config_descriptor.iConfiguration">
Index of string descriptor describing this configuration 
</member>
        <member name="F:libusb_config_descriptor.bConfigurationValue">
Identifier value for this configuration 
</member>
        <member name="F:libusb_config_descriptor.bNumInterfaces">
Number of interfaces supported by this configuration 
</member>
        <member name="F:libusb_config_descriptor.wTotalLength">
Total length of data returned for this configuration 
</member>
        <member name="F:libusb_config_descriptor.bDescriptorType">
Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_CONFIG LIBUSB_DT_CONFIG
	 * in this context. 
</member>
        <member name="F:libusb_config_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_config_descriptor">
\ingroup libusb_desc
 * A structure representing the standard USB configuration descriptor. This
 * descriptor is documented in section 9.6.3 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.

</member>
        <member name="F:libusb_interface.num_altsetting">
The number of alternate settings that belong to this interface.
	 * Must be non-negative. 
</member>
        <member name="T:libusb_interface">
\ingroup libusb_desc
 * A collection of alternate settings for a particular USB interface.


Array of interfaces supported by this configuration. The length of
	 * this array is determined by the bNumInterfaces field. 
</member>
        <member name="F:libusb_interface_descriptor.extra_length">
Length of the extra descriptors, in bytes. Must be non-negative. 
</member>
        <member name="F:libusb_interface_descriptor.extra">
Extra descriptors. If libusb encounters unknown interface descriptors,
	 * it will store them here, should you wish to parse them. 
</member>
        <member name="F:libusb_interface_descriptor.iInterface">
Index of string descriptor describing this interface 
</member>
        <member name="F:libusb_interface_descriptor.bInterfaceProtocol">
USB-IF protocol code for this interface, qualified by the
	 * bInterfaceClass and bInterfaceSubClass values 
</member>
        <member name="F:libusb_interface_descriptor.bInterfaceSubClass">
USB-IF subclass code for this interface, qualified by the
	 * bInterfaceClass value 
</member>
        <member name="F:libusb_interface_descriptor.bInterfaceClass">
USB-IF class code for this interface. See \ref libusb_class_code. 
</member>
        <member name="F:libusb_interface_descriptor.bNumEndpoints">
Number of endpoints used by this interface (excluding the control
	 * endpoint). 
</member>
        <member name="F:libusb_interface_descriptor.bAlternateSetting">
Value used to select this alternate setting for this interface 
</member>
        <member name="F:libusb_interface_descriptor.bInterfaceNumber">
Number of this interface 
</member>
        <member name="F:libusb_interface_descriptor.bDescriptorType">
Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_INTERFACE LIBUSB_DT_INTERFACE
	 * in this context. 
</member>
        <member name="F:libusb_interface_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_interface_descriptor">
\ingroup libusb_desc
 * A structure representing the standard USB interface descriptor. This
 * descriptor is documented in section 9.6.5 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.


Array of interface descriptors. The length of this array is determined
	 * by the num_altsetting field. 
</member>
        <member name="F:libusb_interface_association_descriptor_array.length">
Number of interface association descriptors contained. Read-only. 
</member>
        <member name="T:libusb_interface_association_descriptor_array">
\ingroup libusb_desc
 * Structure containing an array of 0 or more interface association
 * descriptors

</member>
        <member name="F:libusb_interface_association_descriptor.iFunction">
Index of string descriptor describing this function 
</member>
        <member name="F:libusb_interface_association_descriptor.bFunctionProtocol">
USB-IF protocol code for this function.
	* These codes are qualified by the values of the bFunctionClass
	* and bFunctionSubClass fields.

</member>
        <member name="F:libusb_interface_association_descriptor.bFunctionSubClass">
USB-IF subclass code for this function.
	* If this field is not set to 0xff, all values are reserved
	* for assignment by the USB-IF

</member>
        <member name="F:libusb_interface_association_descriptor.bFunctionClass">
USB-IF class code for this function.
	* A value of zero is not allowed in this descriptor.
	* If this field is 0xff, the function class is vendor-specific.
	* All other values are reserved for assignment by the USB-IF.

</member>
        <member name="F:libusb_interface_association_descriptor.bInterfaceCount">
Number of contiguous interfaces that are associated with
	* this function 
</member>
        <member name="F:libusb_interface_association_descriptor.bFirstInterface">
Interface number of the first interface that is associated
	* with this function 
</member>
        <member name="F:libusb_interface_association_descriptor.bDescriptorType">
Descriptor type. Will have value
	* \ref libusb_descriptor_type::LIBUSB_DT_INTERFACE_ASSOCIATION
	* LIBUSB_DT_INTERFACE_ASSOCIATION in this context. 
</member>
        <member name="F:libusb_interface_association_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_interface_association_descriptor">
\ingroup libusb_desc
 * A structure representing the standard USB interface association descriptor.
 * This descriptor is documented in section 9.6.4 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.


Array of interface association descriptors. The size of this array
	 * is determined by the length field.

</member>
        <member name="F:libusb_endpoint_descriptor.extra_length">
Length of the extra descriptors, in bytes. Must be non-negative. 
</member>
        <member name="F:libusb_endpoint_descriptor.extra">
Extra descriptors. If libusb encounters unknown endpoint descriptors,
	 * it will store them here, should you wish to parse them. 
</member>
        <member name="F:libusb_endpoint_descriptor.bSynchAddress">
For audio devices only: the address if the synch endpoint 
</member>
        <member name="F:libusb_endpoint_descriptor.bRefresh">
For audio devices only: the rate at which synchronization feedback
	 * is provided. 
</member>
        <member name="F:libusb_endpoint_descriptor.bInterval">
Interval for polling endpoint for data transfers. 
</member>
        <member name="F:libusb_endpoint_descriptor.wMaxPacketSize">
Maximum packet size this endpoint is capable of sending/receiving. 
</member>
        <member name="F:libusb_endpoint_descriptor.bmAttributes">
Attributes which apply to the endpoint when it is configured using
	 * the bConfigurationValue. Bits 0:1 determine the transfer type and
	 * correspond to \ref libusb_endpoint_transfer_type. Bits 2:3 are only used
	 * for isochronous endpoints and correspond to \ref libusb_iso_sync_type.
	 * Bits 4:5 are also only used for isochronous endpoints and correspond to
	 * \ref libusb_iso_usage_type. Bits 6:7 are reserved. 
</member>
        <member name="F:libusb_endpoint_descriptor.bEndpointAddress">
The address of the endpoint described by this descriptor. Bits 0:3 are
	 * the endpoint number. Bits 4:6 are reserved. Bit 7 indicates direction,
	 * see \ref libusb_endpoint_direction. 
</member>
        <member name="F:libusb_endpoint_descriptor.bDescriptorType">
Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_ENDPOINT LIBUSB_DT_ENDPOINT in
	 * this context. 
</member>
        <member name="F:libusb_endpoint_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_endpoint_descriptor">
\ingroup libusb_desc
 * A structure representing the standard USB endpoint descriptor. This
 * descriptor is documented in section 9.6.6 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.


Array of endpoint descriptors. This length of this array is determined
	 * by the bNumEndpoints field. 
</member>
        <member name="F:libusb_device_descriptor.bNumConfigurations">
Number of possible configurations 
</member>
        <member name="F:libusb_device_descriptor.iSerialNumber">
Index of string descriptor containing device serial number 
</member>
        <member name="F:libusb_device_descriptor.iProduct">
Index of string descriptor describing product 
</member>
        <member name="F:libusb_device_descriptor.iManufacturer">
Index of string descriptor describing manufacturer 
</member>
        <member name="F:libusb_device_descriptor.bcdDevice">
Device release number in binary-coded decimal 
</member>
        <member name="F:libusb_device_descriptor.idProduct">
USB-IF product ID 
</member>
        <member name="F:libusb_device_descriptor.idVendor">
USB-IF vendor ID 
</member>
        <member name="F:libusb_device_descriptor.bMaxPacketSize0">
Maximum packet size for endpoint 0 
</member>
        <member name="F:libusb_device_descriptor.bDeviceProtocol">
USB-IF protocol code for the device, qualified by the bDeviceClass and
	 * bDeviceSubClass values 
</member>
        <member name="F:libusb_device_descriptor.bDeviceSubClass">
USB-IF subclass code for the device, qualified by the bDeviceClass
	 * value 
</member>
        <member name="F:libusb_device_descriptor.bDeviceClass">
USB-IF class code for the device. See \ref libusb_class_code. 
</member>
        <member name="F:libusb_device_descriptor.bcdUSB">
USB specification release number in binary-coded decimal. A value of
	 * 0x0200 indicates USB 2.0, 0x0110 indicates USB 1.1, etc. 
</member>
        <member name="F:libusb_device_descriptor.bDescriptorType">
Descriptor type. Will have value
	 * \ref libusb_descriptor_type::LIBUSB_DT_DEVICE LIBUSB_DT_DEVICE in this
	 * context. 
</member>
        <member name="F:libusb_device_descriptor.bLength">
Size of this descriptor (in bytes) 
</member>
        <member name="T:libusb_device_descriptor">
\ingroup libusb_desc
 * A structure representing the standard USB device descriptor. This
 * descriptor is documented in section 9.6.1 of the USB 3.0 specification.
 * All multiple-byte fields are represented in host-endian format.

</member>
        <member name="T:libusb_bos_type">
\ingroup libusb_desc
 * USB capability types

</member>
        <member name="F:LIBUSB_BT_PLATFORM_DESCRIPTOR">
Platform descriptor 
</member>
        <member name="F:LIBUSB_BT_CONTAINER_ID">
Container ID type 
</member>
        <member name="F:LIBUSB_BT_SS_USB_DEVICE_CAPABILITY">
SuperSpeed USB device capability 
</member>
        <member name="F:LIBUSB_BT_USB_2_0_EXTENSION">
USB 2.0 extensions 
</member>
        <member name="F:LIBUSB_BT_WIRELESS_USB_DEVICE_CAPABILITY">
Wireless USB device capability 
</member>
        <member name="T:libusb_ss_usb_device_capability_attributes">
\ingroup libusb_desc
 * Masks for the bits of the
 * \ref libusb_ss_usb_device_capability_descriptor::bmAttributes "bmAttributes" field
 * field of the SuperSpeed USB Device Capability descriptor.

</member>
        <member name="F:LIBUSB_BM_LTM_SUPPORT">
Supports Latency Tolerance Messages (LTM) 
</member>
        <member name="T:libusb_usb_2_0_extension_attributes">
\ingroup libusb_desc
 * Masks for the bits of the
 * \ref libusb_usb_2_0_extension_descriptor::bmAttributes "bmAttributes" field
 * of the USB 2.0 Extension descriptor.

</member>
        <member name="F:LIBUSB_BM_LPM_SUPPORT">
Supports Link Power Management (LPM) 
</member>
        <member name="T:libusb_supported_speed">
\ingroup libusb_desc
 * Supported speeds (wSpeedSupported) bitfield. Indicates what
 * speeds the device supports.

</member>
        <member name="F:LIBUSB_SUPER_SPEED_OPERATION">
Superspeed operation supported (5000MBit/s). 
</member>
        <member name="F:LIBUSB_HIGH_SPEED_OPERATION">
High speed operation supported (480MBit/s). 
</member>
        <member name="F:LIBUSB_FULL_SPEED_OPERATION">
Full speed operation supported (12MBit/s). 
</member>
        <member name="F:LIBUSB_LOW_SPEED_OPERATION">
Low speed operation supported (1.5MBit/s). 
</member>
        <member name="T:libusb_iso_usage_type">
\ingroup libusb_desc
 * Usage type for isochronous endpoints. Values for bits 4:5 of the
 * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 * libusb_endpoint_descriptor.

</member>
        <member name="F:LIBUSB_ISO_USAGE_TYPE_IMPLICIT">
Implicit feedback Data endpoint 
</member>
        <member name="F:LIBUSB_ISO_USAGE_TYPE_FEEDBACK">
Feedback endpoint 
</member>
        <member name="F:LIBUSB_ISO_USAGE_TYPE_DATA">
Data endpoint 
</member>
        <member name="T:libusb_iso_sync_type">
\ingroup libusb_desc
 * Synchronization type for isochronous endpoints. Values for bits 2:3 of the
 * \ref libusb_endpoint_descriptor::bmAttributes "bmAttributes" field in
 * libusb_endpoint_descriptor.

</member>
        <member name="F:LIBUSB_ISO_SYNC_TYPE_SYNC">
Synchronous 
</member>
        <member name="F:LIBUSB_ISO_SYNC_TYPE_ADAPTIVE">
Adaptive 
</member>
        <member name="F:LIBUSB_ISO_SYNC_TYPE_ASYNC">
Asynchronous 
</member>
        <member name="F:LIBUSB_ISO_SYNC_TYPE_NONE">
No synchronization 
</member>
        <member name="T:libusb_request_recipient">
\ingroup libusb_misc
 * Recipient bits of the
 * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 * transfers. Values 4 through 31 are reserved. 
</member>
        <member name="F:LIBUSB_RECIPIENT_OTHER">
Other 
</member>
        <member name="F:LIBUSB_RECIPIENT_ENDPOINT">
Endpoint 
</member>
        <member name="F:LIBUSB_RECIPIENT_INTERFACE">
Interface 
</member>
        <member name="F:LIBUSB_RECIPIENT_DEVICE">
Device 
</member>
        <member name="T:libusb_request_type">
\ingroup libusb_misc
 * Request type bits of the
 * \ref libusb_control_setup::bmRequestType "bmRequestType" field in control
 * transfers. 
</member>
        <member name="F:LIBUSB_REQUEST_TYPE_RESERVED">
Reserved 
</member>
        <member name="F:LIBUSB_REQUEST_TYPE_VENDOR">
Vendor 
</member>
        <member name="F:LIBUSB_REQUEST_TYPE_CLASS">
Class 
</member>
        <member name="F:LIBUSB_REQUEST_TYPE_STANDARD">
Standard 
</member>
        <member name="T:libusb_standard_request">
\ingroup libusb_misc
 * Standard requests, as defined in table 9-5 of the USB 3.0 specifications 
</member>
        <member name="F:LIBUSB_SET_ISOCH_DELAY">
Delay from the time a host transmits a packet to the time it is
	  * received by the device. 
</member>
        <member name="F:LIBUSB_REQUEST_SET_SEL">
Sets both the U1 and U2 Exit Latency 
</member>
        <member name="F:LIBUSB_REQUEST_SYNCH_FRAME">
Set then report an endpoint's synchronization frame 
</member>
        <member name="F:LIBUSB_REQUEST_SET_INTERFACE">
Select an alternate interface for the specified interface 
</member>
        <member name="F:LIBUSB_REQUEST_GET_INTERFACE">
Return the selected alternate setting for the specified interface 
</member>
        <member name="F:LIBUSB_REQUEST_SET_CONFIGURATION">
Set device configuration 
</member>
        <member name="F:LIBUSB_REQUEST_GET_CONFIGURATION">
Get the current device configuration value 
</member>
        <member name="F:LIBUSB_REQUEST_SET_DESCRIPTOR">
Used to update existing descriptors or add new descriptors 
</member>
        <member name="F:LIBUSB_REQUEST_GET_DESCRIPTOR">
Get the specified descriptor 
</member>
        <member name="F:LIBUSB_REQUEST_SET_ADDRESS">
Set device address for all future accesses 
</member>
        <member name="F:LIBUSB_REQUEST_SET_FEATURE">
Set or enable a specific feature 
</member>
        <member name="F:LIBUSB_REQUEST_CLEAR_FEATURE">
Clear or disable a specific feature 
</member>
        <member name="F:LIBUSB_REQUEST_GET_STATUS">
Request status of the specific recipient 
</member>
        <member name="T:libusb_endpoint_transfer_type">
\ingroup libusb_desc
 * Endpoint transfer type. Values for bits 0:1 of the
 * \ref libusb_endpoint_descriptor::bmAttributes "endpoint attributes" field.

</member>
        <member name="F:LIBUSB_ENDPOINT_TRANSFER_TYPE_INTERRUPT">
Interrupt endpoint 
</member>
        <member name="F:LIBUSB_ENDPOINT_TRANSFER_TYPE_BULK">
Bulk endpoint 
</member>
        <member name="F:LIBUSB_ENDPOINT_TRANSFER_TYPE_ISOCHRONOUS">
Isochronous endpoint 
</member>
        <member name="F:LIBUSB_ENDPOINT_TRANSFER_TYPE_CONTROL">
Control endpoint 
</member>
        <member name="T:libusb_endpoint_direction">
\ingroup libusb_desc
 * Endpoint direction. Values for bit 7 of the
 * \ref libusb_endpoint_descriptor::bEndpointAddress "endpoint address" scheme.

</member>
        <member name="F:LIBUSB_ENDPOINT_IN">
In: device-to-host 
</member>
        <member name="F:LIBUSB_ENDPOINT_OUT">
Out: host-to-device 
</member>
        <member name="T:libusb_descriptor_type">
\ingroup libusb_desc
 * Descriptor types as defined by the USB specification. 
</member>
        <member name="F:LIBUSB_DT_SS_ENDPOINT_COMPANION">
SuperSpeed Endpoint Companion descriptor 
</member>
        <member name="F:LIBUSB_DT_SUPERSPEED_HUB">
SuperSpeed Hub descriptor 
</member>
        <member name="F:LIBUSB_DT_HUB">
Hub descriptor 
</member>
        <member name="F:LIBUSB_DT_PHYSICAL">
Physical descriptor 
</member>
        <member name="F:LIBUSB_DT_REPORT">
HID report descriptor 
</member>
        <member name="F:LIBUSB_DT_HID">
HID descriptor 
</member>
        <member name="F:LIBUSB_DT_DEVICE_CAPABILITY">
Device Capability descriptor 
</member>
        <member name="F:LIBUSB_DT_BOS">
BOS descriptor 
</member>
        <member name="F:LIBUSB_DT_INTERFACE_ASSOCIATION">
Interface Association Descriptor.
	* See libusb_interface_association_descriptor 
</member>
        <member name="F:LIBUSB_DT_ENDPOINT">
Endpoint descriptor. See libusb_endpoint_descriptor. 
</member>
        <member name="F:LIBUSB_DT_INTERFACE">
Interface descriptor. See libusb_interface_descriptor. 
</member>
        <member name="F:LIBUSB_DT_STRING">
String descriptor 
</member>
        <member name="F:LIBUSB_DT_CONFIG">
Configuration descriptor. See libusb_config_descriptor. 
</member>
        <member name="F:LIBUSB_DT_DEVICE">
Device descriptor. See libusb_device_descriptor. 
</member>
        <member name="T:libusb_class_code">
\def libusb_le16_to_cpu
 * \ingroup libusb_misc
 * Convert a 16-bit value from little-endian to host-endian format. On
 * little endian systems, this function does nothing. On big endian systems,
 * the bytes are swapped.
 * \param x the little-endian value to convert
 * \returns the value in host-endian byte order

\ingroup libusb_desc
 * Device and/or Interface Class codes 
</member>
        <member name="F:LIBUSB_CLASS_VENDOR_SPEC">
Class is vendor-specific 
</member>
        <member name="F:LIBUSB_CLASS_APPLICATION">
Application class 
</member>
        <member name="F:LIBUSB_CLASS_MISCELLANEOUS">
Miscellaneous class 
</member>
        <member name="F:LIBUSB_CLASS_WIRELESS">
Wireless class 
</member>
        <member name="F:LIBUSB_CLASS_DIAGNOSTIC_DEVICE">
Diagnostic Device 
</member>
        <member name="F:LIBUSB_CLASS_PERSONAL_HEALTHCARE">
Personal Healthcare 
</member>
        <member name="F:LIBUSB_CLASS_VIDEO">
Video 
</member>
        <member name="F:LIBUSB_CLASS_CONTENT_SECURITY">
Content Security 
</member>
        <member name="F:LIBUSB_CLASS_SMART_CARD">
Smart Card 
</member>
        <member name="F:LIBUSB_CLASS_DATA">
Data class 
</member>
        <member name="F:LIBUSB_CLASS_HUB">
Hub class 
</member>
        <member name="F:LIBUSB_CLASS_MASS_STORAGE">
Mass storage class 
</member>
        <member name="F:LIBUSB_CLASS_PRINTER">
Printer class 
</member>
        <member name="F:LIBUSB_CLASS_IMAGE">
Image class 
</member>
        <member name="F:LIBUSB_CLASS_PHYSICAL">
Physical 
</member>
        <member name="F:LIBUSB_CLASS_HID">
Human Interface Device class 
</member>
        <member name="F:LIBUSB_CLASS_COMM">
Communications class 
</member>
        <member name="F:LIBUSB_CLASS_AUDIO">
Audio class 
</member>
        <member name="F:LIBUSB_CLASS_PER_INTERFACE">
In the context of a \ref libusb_device_descriptor "device descriptor",
	 * this bDeviceClass value indicates that each interface specifies its
	 * own class information and all interfaces operate independently.

</member>
        <member name="M:librador_set_device_mode(System.Int32)">
As above, a1 and a2
</member>
        <!-- Discarding badly formed XML document comment for member 'M:libusb_cpu_to_le16(System.UInt16!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:libusb_pollfd.events'. -->
        <!-- Discarding badly formed XML document comment for member 'M:libusb_cpu_to_le16(System.UInt16!System.Runtime.CompilerServices.IsConst)'. -->
        <!-- Discarding badly formed XML document comment for member 'F:libusb_pollfd.events'. -->
    </members>
</doc>